## Node

### 介绍

>面向网络而设计
>
>基于事件循环的异步I/O框架
>
>利用单线程，原理多线程死锁、状态同步等问题，利用异步I/O让单线程原理阻塞
>
>通常所说Node是单线程的，仅仅是指JavaScript执行在单线程中，I/O任务另有线程池
>
>事件循环是典型的生产者/消费者模型。
>
>事件驱动的实质：主循环加事件触发的方式来运行程序

### 优点

> 高并发、高性能
> 前后端编程环境统一，大大降低了前后端转换所需要的上下文交换代价
> 事件的编程方式具有轻量级、松耦合、只关注事务点等优势
> 跨平台运行，得益于Node架构中的平台层架构——libuv(跨平台基础组件)

### 特点

> Node中绝大多操作都是以异步的方式进行的
> Node不处理UI，但用与浏览器相同的机制和原理运行
> Node保持了JavaScript在浏览器中单线程的特点

### 单线程的优缺点

> 好处：
> 没有线程上下文切换带来的性能开销
> 缺处：
> 无法利用多核CPU
> 健壮性上，错误会引起整个应用退出
> 如果大量计算占用CPU将导致CPU时间片无法释放，从而导致无法继续调用异步I/O

### 应用场景

> I/O密集型(主要)
> Node擅长并行I/O，得益于Node基于事件循环，资源占用少
> 分布式应用
> 实时应用

### node-webkit

> 将Node中的事件循环和Webkit的事件循环融合在一起，整合了UI构建和后端处理，是桌面应用程序开发可以完全由HTML、CSS、JavaScript完成

### API

[nodeAPI](http://nodejs.cn/api/)

#### process

> `process` 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 `require()`。 它也可以使用 `require()` 显式地访问：

```js
const process = require('process');
```

可以通过`console.log('process')`打印出来看

将`console.log('process')`写在一个js文件，然后`node js文件名`来执行这个js文件。

### 模块

Node中一个js文件就是一个文件模块，每一个文件模块都是一个moudle对象。

模块引用、模块定义、模块标识

`var math = require('math')`

'math'为模块标识，require()方法来进行模块引用，引入外部模块API到当前上下文中。

exports对象用于导出当前模块的方法或者变量，它是唯一导出的出口

moudle对象代表模块本身，exports是moudle的属性。

模块标识就是require()方法的参数，可以是相对路径(`.或..`开始)、绝对路径(`/`开始)，可以没有`.js`后缀

在每个模块中， `module` 的自由变量是对表示当前模块的对象的引用。 为方便起见，还可以通过全局模块的 `exports` 访问 `module.exports`。 `module` 实际上不是全局的，而是每个模块本地的。

#### 模块环境探测

> 现今，CommonJS Modules 与 AMD 有着广泛的应用，如果确定 AMD 的 define 是可用的，我们当然可以使用 define 来编写模块化的代码。然而，我们不能假定我们的代码必然运行于 AMD 环境下。有没有办法可以让我们的代码既兼容于 CommonJS Modules 或 AMD 规范，又能在一般环境下运行呢？
>
> 其实我们只需要在某个地方加上对 CommonJS Modules 与 AMD 的探测并根据探测结果来“注册”自己就可以了，以上那些模块模式仍然有用。
>
> AMD 定义了 define 函数，我们可以使用 typeof 探测该函数是否已定义。若要更严格一点，可以继续判断 define.amd 是否有定义。另外，SeaJS 也使用了 define 函数，但和 AMD 的 define 又不太一样。
>
> 对于 CommonJS，可以检查 exports 或是 module.exports 是否有定义。

#### `module.children`

> 被该模块引用的模块对象。

#### exports和module.exports

`exports` 变量是在模块的文件级作用域内可用的

#### Node引入模块要经历3步

+ (1)路径分析
+ (2)文件定位
+ (3)编译执行

在Node中，模块分为两种：

核心模块：Node提供的模块，路径分析中优先，加载速度最快，部分核心模块在Node进程启动时就被直接加载进内存。

文件模块：用户编写的模块，运行时动态加载。

Node对引入过的模块会进行缓存，引入模块时优先从缓存中加载。

文件扩展名分析，Node会按`.js`,`.json`,`.node`的次序补足扩展名。

所以如果是`.json`,`.node`文件，带上扩展名会加快定位速度。

`.node`文件是用C/C++编写的扩展文件

### 函数式编程

高阶函数：将函数作为输入或者返回值

偏函数：根据部分入参返回定制函数

### 补充

* 回调函数是最好的接收异步调用返回数据的方式

* ```
  浏览器中JavaScript和UI共享一个线程，JavaScript执行时间过长会导致UI渲染和响应被中断(如果脚本执行时间超过100ms，用户会感觉到卡顿，以为页面停止响应)，通过异步消除UI阻塞现象。在Node中，长时间的CPU占用会导致后续的异步I/O发不出调用，已完成的异步I/O的回调也不及时。
  
  浏览器对于该缺陷的解决方式：
  HTML5推出Web Workers标准，创建工作线程来进行计算，通过消息传递的方式来传递运行结果
  
  Node对于该缺陷的解决方式：
  方式一：child_process，与Web Workers相同的思路，将计算分发给子进程，通过进程之间的事件消息来传递运行结果。Master-Worker管理方式。通过这种方式将计算和I/O分离
  方式二：C/C++扩展
  ```

* Chrome浏览器中V8作为JavaScript引擎，Webkit作为布局引擎

* 如果对一个时间添加超过10个监听器，会得到一条警告，可以调用`emitter.setMaxListeners(0)`来消除。但最好不要添加过多监听器，因为可能导致过多占用CPU的情景、内存泄露等。

* EventEmitter对error事件特殊对待，没有对error时间添加监听器将会直接作为异常抛出，如果外部没有捕获将引起线程退出。所以通常应该对error事件做处理

* 知识误区纠正：同步/异步和阻塞/非阻塞虽然在效果上有所相同，但从计算机内核I/O上看是两回事

  目前操作系统层面的AIO仅Linux下有，且操作系统对它的支持并不完善，比如无法利用系统缓存，固AIO并不常用。